use Transition::{Unchanged, ChangedTo};
use std::ops::{ControlFlow, FromResidual, Try};

pub enum Transition<TCurr, TNext> {
	Unchanged(TCurr),
	ChangedTo(TNext),
}

impl<TCurr, TNext> FromResidual for Transition<TCurr, TNext> {
	fn from_residual(residual: <Self as Try>::Residual) -> Self {
		ChangedTo(residual)
	}
}

impl<TCurr, TNext> Try for Transition<TCurr, TNext> {
	type Output = TCurr;
	type Residual = TNext;

	fn from_output(output: Self::Output) -> Self {
		Unchanged(output)
	}

	fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
		match self {
			Unchanged(same) => {
				ControlFlow::Continue(same)
			}
			ChangedTo(new) => {
				ControlFlow::Break(new)
			}
		}
	}
}

/*
// My crate defines this struct
pub enum Transition<TCurr, TNext> {
    Unchanged(TCurr),
    ChangedTo(TNext),
}

// And a macro that generates types that I allow you to use it like this:
// Imagine you have this struct: (Macro input)
struct Villager<State> {
    /../  // bunch of other fields
    state: State,
}

// Some state types (Macro output)
struct Idle;
struct Hungry;
struct Fleeing { danger_origin: GameObject };

// You need an enum that can store any state (Macro output)
enum VillagerEnum {
    Idle(Villager<Idle),
    Hungry(Villager<Hungry>),
    Fleeing(Villager<Fleeing>),
}

// And you want a trait that defines if a state should transition:
trait ITick {
    fn tick(self, delta_time: f64) -> Transition<Self, VillagerEnum>;
}

// The code generated by the macro allows you to do this:
impl ITick for Villager<Idle> {
    // Check for transitions in order of priority, more important ones should be checked first
    fn tick(mut self, delta_time: f64) -> Transition<Self, VillagerEnum> {
        self = self.check_hunger?; // `Transition` implements `Try`, returning early if the state did change, otherwise you get `self` back at the same state as before
        
        self = self.check_nearby_dangers()?;
        
        /../ any other checks
        
        // If none succeed, return as unchanged:
        Unchanged(self)
    }
}

impl<T> Villager<T> {
    fn check_hunger(self) -> Transition<Self, VillagerEnum> {
        if self.hunger > 0.8 {
            self.transition_to(Hungry).into()
        } else {
            Unchanged(self)
        }
    }
}

*/